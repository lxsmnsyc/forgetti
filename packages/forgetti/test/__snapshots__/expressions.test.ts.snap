// Vitest Snapshot v1

exports[`expressions > should optimize JSX Element 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 10),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.title,
    _eq2 = _$$equals(_c, 2, _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2,
    _v4 = _eq ? _c[3] : _c[3] = _v.title,
    _eq3 = _$$equals(_c, 4, _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4,
    _eq4 = _eq2 && _eq3,
    _v6 = _eq4 ? _c[5] : _c[5] = <h1 title={_v3}>Title: {_v5}</h1>,
    _eq5 = _$$equals(_c, 6, _v6),
    _v7 = _eq5 ? _c[6] : _c[6] = _v6,
    _v8 = _eq ? _c[7] : _c[7] = _v.children,
    _eq6 = _$$equals(_c, 8, _v8),
    _v9 = _eq6 ? _c[8] : _c[8] = _v8,
    _eq7 = _eq5 && _eq6,
    _v10 = _eq7 ? _c[9] : _c[9] = <div>
      {_v7}
      {_v9}
    </div>;
  return _v10;
}"
`;

exports[`expressions > should optimize JSX Fragment 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 10),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.title,
    _eq2 = _$$equals(_c, 2, _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2,
    _v4 = _eq ? _c[3] : _c[3] = _v.title,
    _eq3 = _$$equals(_c, 4, _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4,
    _eq4 = _eq2 && _eq3,
    _v6 = _eq4 ? _c[5] : _c[5] = <h1 title={_v3}>Title: {_v5}</h1>,
    _eq5 = _$$equals(_c, 6, _v6),
    _v7 = _eq5 ? _c[6] : _c[6] = _v6,
    _v8 = _eq ? _c[7] : _c[7] = _v.children,
    _eq6 = _$$equals(_c, 8, _v8),
    _v9 = _eq6 ? _c[8] : _c[8] = _v8,
    _eq7 = _eq5 && _eq6,
    _v10 = _eq7 ? _c[9] : _c[9] = <>
      {_v7}
      {_v9}
    </>;
  return _v10;
}"
`;

exports[`expressions > should optimize array expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 8),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.a,
    _eq2 = _$$equals(_c, 2, _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2,
    _v4 = _eq ? _c[3] : _c[3] = _v.b,
    _eq3 = _$$equals(_c, 4, _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4,
    _v6 = _eq ? _c[5] : _c[5] = _v.c,
    _eq4 = _$$equals(_c, 6, _v6),
    _v7 = _eq4 ? _c[6] : _c[6] = _v6,
    _eq5 = _eq2 && _eq3 && _eq4,
    _v8 = _eq5 ? _c[7] : _c[7] = [_v3, _v5, ..._v7];
  return _v8;
}"
`;

exports[`expressions > should optimize assignment expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 5),
    a,
    b,
    c,
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.x,
    _eq2 = _$$equals(_c, 2, _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2;
  const _hoisted = c = _v3;
  let _eq3 = _$$equals(_c, 3, _hoisted),
    _v4 = _eq3 ? _c[3] : _c[3] = _hoisted;
  const _hoisted2 = b = _v4;
  let _eq4 = _$$equals(_c, 4, _hoisted2),
    _v5 = _eq4 ? _c[4] : _c[4] = _hoisted2;
  const _hoisted3 = a = _v5;
  _hoisted3;
}"
`;

exports[`expressions > should optimize binary expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 6),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.a,
    _eq2 = _$$equals(_c, 2, _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2,
    _v4 = _eq ? _c[3] : _c[3] = _v.b,
    _eq3 = _$$equals(_c, 4, _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4,
    _eq4 = _eq2 && _eq3,
    _v6 = _eq4 ? _c[5] : _c[5] = _v3 + _v5;
  return _v6;
}"
`;

exports[`expressions > should optimize call expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 2),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.call();
  return _v2;
}"
`;

exports[`expressions > should optimize conditional expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$branch as _$$branch } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 4),
    _eq = _$$equals(_c, 0, props),
    _v2 = _eq ? _c[0] : _c[0] = props,
    _v3 = _eq ? _c[1] : _c[1] = _v2.a,
    _v;
  if (_v3) {
    let _c2 = _$$branch(_c, 2, 1),
      _v4 = _eq ? _c2[0] : _c2[0] = _v2.b;
    _v = _v4;
  } else {
    let _c3 = _$$branch(_c, 3, 1),
      _v5 = _eq ? _c3[0] : _c3[0] = _v2.c;
    _v = _v5;
  }
  return _v;
}"
`;

exports[`expressions > should optimize function expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 2),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = () => {
      console.log(props.message);
    };
  const callback = _v2;
}"
`;

exports[`expressions > should optimize guaranteed literals 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 1),
    _v = 0 in _c ? _c[0] : _c[0] = 1 + 2;
  return _v;
}"
`;

exports[`expressions > should optimize identifiers 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 1),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props;
  return _v;
}"
`;

exports[`expressions > should optimize logical expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$branch as _$$branch } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 3),
    _eq = _$$equals(_c, 0, props),
    _v2 = _eq ? _c[0] : _c[0] = props,
    _v3 = _eq ? _c[1] : _c[1] = _v2.a,
    _v;
  if (_v3) {
    let _c2 = _$$branch(_c, 2, 1),
      _v4 = _eq ? _c2[0] : _c2[0] = _v2.b;
    _v = _v4;
  } else _v = _v3;
  return _v;
}"
`;

exports[`expressions > should optimize member expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 2),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.example;
  return _v2;
}"
`;

exports[`expressions > should optimize new expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 3),
    _v = 0 in _c ? _c[0] : _c[0] = X,
    _eq = _$$equals(_c, 1, props),
    _v2 = _eq ? _c[1] : _c[1] = props,
    _v3 = _eq ? _c[2] : _c[2] = new _v(_v2);
  return _v3;
}"
`;

exports[`expressions > should optimize object expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 6),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.a,
    _v3 = _eq ? _c[2] : _c[2] = _v.b,
    _v4 = _eq ? _c[3] : _c[3] = _v.c,
    _eq2 = _$$equals(_c, 4, _v4),
    _v5 = _eq2 ? _c[4] : _c[4] = _v4,
    _eq3 = _eq && _eq2,
    _v6 = _eq3 ? _c[5] : _c[5] = {
      a: _v2,
      b: _v3,
      ..._v5
    };
  return _v6;
}"
`;

exports[`expressions > should optimize sequence expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 3),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.a(),
    _v3 = _eq ? _c[2] : _c[2] = _v.b();
  return _v2, _v3;
}"
`;

exports[`expressions > should optimize tagged templates 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 8),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.tag,
    _eq2 = _$$equals(_c, 2, _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2,
    _v4 = _eq ? _c[3] : _c[3] = _v.a(),
    _eq3 = _$$equals(_c, 4, _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4,
    _v6 = _eq ? _c[5] : _c[5] = _v.b(),
    _eq4 = _$$equals(_c, 6, _v6),
    _v7 = _eq4 ? _c[6] : _c[6] = _v6,
    _eq5 = _eq2 && _eq3 && _eq4,
    _v8 = _eq5 ? _c[7] : _c[7] = _v3\`\${_v5}, \${_v7}\`;
  return _v8;
}"
`;

exports[`expressions > should optimize template literals 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 6),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.a(),
    _eq2 = _$$equals(_c, 2, _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2,
    _v4 = _eq ? _c[3] : _c[3] = _v.b(),
    _eq3 = _$$equals(_c, 4, _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4,
    _eq4 = _eq2 && _eq3,
    _v6 = _eq4 ? _c[5] : _c[5] = \`\${_v3}, \${_v5}\`;
  return _v6;
}"
`;

exports[`expressions > should optimize unary expressions 1`] = `
"import { useMemo as _useMemo } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useMemo, 4),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.a,
    _eq2 = _$$equals(_c, 2, _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2,
    _v4 = _eq2 ? _c[3] : _c[3] = !_v3;
  return _v4;
}"
`;
